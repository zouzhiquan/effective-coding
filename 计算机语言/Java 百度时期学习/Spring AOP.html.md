---
author: zouzq7@163.com
created: "2018-09-04 01:32:35 +0000"
exporter-version: Evernote Mac 9.6.4 (470194)
source: desktop.mac
title: Spring AOP
updated: "2018-09-06 03:09:20 +0000"
---

<div>

Spring AOP
使用场景蛮多的属性检查、日志等，所有拦截下来可以在切面共同做的事儿似乎都可以用AOP（面向切面）的方式解决。在面试的过程中AOP
也是除Ioc及MVC 以外问的较多的一个点，通常是这样的：

</div>

<div>

AOP 是什么？面向切面编程。

</div>

<div>

Spring AOP 是如何实现的？
配置下拦截器，完成具体的处理逻辑，其实本质就是一个动态代理。

</div>

<div>

那Spring 实现动态代理的方式有哪些？CGLib、JDK 原生

</div>

<div>

那这两种方式默认使用哪一种，如何指配？#\*&@¥&@\*¥&\*@#¥&

</div>

<div>

那JDK 原生方式与CGlib 区别说一下？&\*&#¥#¥

</div>

<div>

提到了CGlib的实现是ASM，那ASM 具体的原理是怎样的？#\*&@¥&@\*¥&\*@#¥&

</div>

<div>

说一下ASM 几个核心的函数？#\*&@¥&@\*¥&\*@#¥&

</div>

<div>

说一下ASM 操作的过程中，JVM 里都发生了哪些事儿？#\*&@¥&@\*¥&\*@#¥&

</div>

<div>

刚才说了这么多反射还有JVM 相关的，如果使用反射的方式向一个List\<String\>
，插入一个Integer，是正常还是Error，为什么？

</div>

<div>

好的，咱来谈谈泛型的擦除。所以会很容易被转移话题的。

</div>

<div>

\

</div>

<div>

其实AOP 相对于具体语言的实现细节，最主要的是它的实现思想。

</div>

<div>

先说一下思想：

</div>

<div>

AOP 面向切面编程，算是对oop
面向对象编程的一种补充，指的在许多流程中都存在某些点需要做类似的事儿，可以将这个点设置为横切关注点（相对的业务处理的是核心关注点），完后完成对应事件的设定。

</div>

<div>

这种场景比如说权限检查、日志等。。

</div>

<div>

要理解整个AOP 过程还需要一点关键词：

</div>

<div>

横切关注点： 具体需要拦截的点，一种发现的过程

</div>

<div>

切面（aspect）：  对横切关注点的一种抽象，一种抽象的过程

</div>

<div>

连接点（joinpoint）：要被拦截到的具体点

</div>

<div>

切入点（pointcut）：对于连接点进行，一种设置拦截定义的过程

</div>

<div>

通知（advice）：具体就是指的拦截到具体的连接点之后的要执行的逻辑代码，分为：前置、后置、最终、环绕
这五类通知

</div>

<div>

目标对象：代理的目标对象

</div>

<div>

织入（weave）：将切面应用到目标对象，并创建对应对象代理创建的过程

</div>

<div>

引入（introduction）：动态代理运行的过程

</div>

<div>

\

</div>

<div>

然后是AOP 后续具体的使用细节及实现原理：

</div>

<div>

使用过程大体是这样的：

</div>

<div>

1、检查业务组件，查看是否存在大量可横切点

</div>

<div>

2、定义切入点

</div>

<div>

3、定义增强处理，就是切入点前后的具体通知

</div>

<div>

4、设置完成，实现对应AOP 操作

</div>

<div>

\

</div>

<div>

Spring 对AOP 的支持是建立在Ioc 的基础上的，也就是AOP 代理有Ioc
容器负责处理依赖关系，及其生成和管理。

</div>

<div>

那么Spring AOP 所依赖的Ioc 里面使用代理的方式是默认使用JDK
原生方式，也可以选配CGlib实现。

</div>

<div>

在使用层面上，JDK 要求实现接口，而CGlib 不用，可以基于类实现。

</div>

<div>

JDK 是根据接口实现一个具体的class
对象然后加载到具体的堆和方法区完成的实现。

</div>

<div>

CGlib 是依赖于ASM
，通过字节码操作根据现有的类，通过添加字节码的方式构建一个新的对应类的子类来完成对应的实现。

</div>

<div>

就当前阶段来说两者在小规模调用差异基本是不大的，当前hibernate
用的就是ASM 方式实现的懒加载。

</div>

<div>

\

</div>
