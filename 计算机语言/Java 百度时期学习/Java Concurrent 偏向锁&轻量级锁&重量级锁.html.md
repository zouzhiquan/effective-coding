---
author: zouzq7@163.com
created: "2018-08-03 15:53:58 +0000"
exporter-version: Evernote Mac 9.6.4 (470194)
source: desktop.mac
title: Java Concurrent 偏向锁&轻量级锁&重量级锁
updated: "2019-04-13 06:53:36 +0000"
---

<div>

再说偏向锁之前先来看一下Java 对象头，Java 对象是分为
对象头、实例数据、对齐填充三部分，创建一个Java
对象所消耗和占用的cpu和内存代价都是很高的（尤其是对齐填充这一块，真的会浪费很多内存），和并发相关性最大的是对象头，因为Java
原生锁（sychronized）的信息是存放在Java
对象头中的。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。

</div>

<div>

对象头中的位数依赖于系统的位数：

</div>

<div>

1、32或64bit存放Mark Word，其中包括存储对象的hashCode或锁信息等。

</div>

<div>

2、32或64bit存放Class Metadata Address，也就是存储到对象类型数据的指针。

</div>

<div>

（3、如果是数组对象的话，使用32或64bit存放Array
length，也就是数组的长度）

</div>

<div>

\

</div>

<div>

mark
word中包括HashCode、分代年龄、锁标记位，hashcode用来表示该对象，分代年龄用来JVM分代回收时使用，有兴趣的同学可以看一下我那篇讲垃圾回收算法及垃圾回收器的文章。在运行期间Mark
Word里存储的数据会随着锁标志位的变化而变化。Mark
Word可能变化为存储以下4种数据：（图片非原创，来自网络）

</div>

<div>

![](Java%20Concurrent%20%E5%81%8F%E5%90%91%E9%94%81&%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81&%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.resources/D79FD1AE-787A-428F-AC10-46C534260A4B.png) 
 \

</div>

<div>

在Java SE1.6
以上里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。

</div>

<div>

注意一点：锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。（这里和reentrantlock对比下，正好儿是相反的）

</div>

<div>

偏向锁使用方式：

</div>

<div>

jvm开启/关闭偏向锁

</div>

<div>

开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0

</div>

<div>

关闭偏向锁：-XX:-UseBiasedLocking

</div>

<div>

\

</div>

<div>

偏向锁原理：（偏向线程无需每次都要取锁、解锁，就偏向线程来说跟无锁时差别不大）

</div>

<div>

在实际的应用中经常存在这样一种情况，锁总是一个线程持有，很少发生争用。也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步，退出同步也无需每次加锁解锁都去CAS更新对象头，如果不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候需要锁膨胀为轻量级锁，才能保证线程间公平竞争锁。

</div>

<div>

\

</div>

<div>

偏向锁加锁过程：

</div>

<div>

1）访问Mark
Word中偏向锁的标识是否设置成1，锁标志位是否为01------确认为可偏向状态。

</div>

<div>

2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。

</div>

<div>

3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark
Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。

</div>

<div>

4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。

</div>

<div>

5）执行同步代码。

</div>

<div>

\

</div>

<div>

轻量级锁：（该线程不会阻塞，响应迅速，存在自旋操作，但是会空耗cpu）

</div>

<div>

每次都需要CAS竞争锁，与偏向锁比较来说的话：

</div>

<div>

1\. 轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁

</div>

<div>

2\. 每次进入退出同步块都需要CAS更新对象头

</div>

<div>

3\. 争夺轻量级锁失败时，自旋尝试抢占锁

</div>

<div>

\

</div>

<div>

加锁过程：

</div>

<div>

1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为"01"状态，是否为偏向锁为"0"），JVM首先将在当前线程的栈帧中建立一个名为Lock
Record的空间，用于存储锁对象目前的Mark Word的拷贝。

</div>

<div>

2）拷贝对象头中的Mark Word复制到锁记录中。

</div>

<div>

3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock
Record的指针，并将Lock record里的owner指针指向object mark
word。如果更新成功，则执行步骤（3），否则执行步骤（4）。

</div>

<div>

4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark
Word的锁标志位设置为"00"，即表示此对象处于轻量级锁定状态。

</div>

<div>

5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark
Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为"10"，Mark
Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

</div>

<div>

\

</div>

<div>

重量级锁：（吞吐量&长时间执行的代码块，CPU资源较少的）

</div>

<div>

轻量级锁多次竞争失败后，线程阻塞，释放锁后，唤醒阻塞的线程，不使用自旋锁，不会那么消耗CPU，重量级锁适合用在同步块执行时间长的情况下。相较于轻量级来说最大区别应该是不进行自旋操作，直接阻塞，

</div>

<div>

\

</div>

<div>

总结：

</div>

<div>

轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能，重量级锁是为处理常存在多线程竞争，同步块执行时间十分长的情况下的锁的方式。

</div>

<div>

\

</div>

<div>

另外还有JVM里面的一点自带优化，具体来说是JIT的优化。

</div>

<div>

锁粗化（Lock
Coarsening）：锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。

</div>

<div>

锁消除（Lock
Elimination）：锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。据来说通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配（同时还可以减少Heap上的垃圾收集开销）。

</div>
